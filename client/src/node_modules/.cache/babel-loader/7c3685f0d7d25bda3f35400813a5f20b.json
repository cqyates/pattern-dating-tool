{"ast":null,"code":"/**\n *\n * Tesseract Worker adapter for browser\n *\n * @fileoverview Tesseract Worker adapter for browser\n * @author Kevin Kwok <antimatter15@gmail.com>\n * @author Guillermo Webster <gui@mit.edu>\n * @author Jerome Wu <jeromewus@gmail.com>\n */\nconst check = require('check-types');\n\nconst resolveURL = require('resolve-url');\n\nconst axios = require('axios');\n\nconst b64toU8Array = require('./b64toU8Array');\n\nconst _require = require('../common/options'),\n      defaultOptions = _require.defaultOptions;\n\nconst _require2 = require('../../package.json'),\n      version = _require2.version;\n/**\n * readFromBlobOrFile\n *\n * @name readFromBlobOrFile\n * @function\n * @access private\n * @param {object} blob A blob or file objec to read\n * @param {function} res callback function after reading completes\n */\n\n\nconst readFromBlobOrFile = (blob, res) => {\n  const fileReader = new FileReader();\n\n  fileReader.onload = () => {\n    res(fileReader.result);\n  };\n\n  fileReader.readAsArrayBuffer(blob);\n};\n/**\n * loadImage\n *\n * @name loadImage\n * @function load image from different source\n * @access private\n * @param {string, object} image - image source, supported formats:\n *   string: URL string, can be relative path\n *   string: base64 image\n *   img HTMLElement: extract image source from src attribute\n *   video HTMLElement: extract image source from poster attribute\n *   canvas HTMLElement: extract image data by converting to Blob\n *   File instance: data from <input type=\"file\" />\n * @returns {array} binary image in array format\n */\n\n\nconst loadImage = image => {\n  if (check.string(image)) {\n    // Base64 Image\n    if (/data:image\\/([a-zA-Z]*);base64,([^\"]*)/.test(image)) {\n      return Promise.resolve(b64toU8Array(image.split(',')[1]));\n    } // Image URL\n\n\n    return axios.get(resolveURL(image), {\n      responseType: 'arraybuffer'\n    }).then(resp => resp.data);\n  }\n\n  if (check.instance(image, HTMLElement)) {\n    if (image.tagName === 'IMG') {\n      return loadImage(image.src);\n    }\n\n    if (image.tagName === 'VIDEO') {\n      return loadImage(image.poster);\n    }\n\n    if (image.tagName === 'CANVAS') {\n      return new Promise(res => {\n        image.toBlob(blob => {\n          readFromBlobOrFile(blob, res);\n        });\n      });\n    }\n  }\n\n  if (check.instance(image, File) || check.instance(image, Blob)) {\n    return new Promise(res => {\n      readFromBlobOrFile(image, res);\n    });\n  }\n\n  return Promise.reject();\n};\n\nconst downloadFile = (path, blob) => {\n  if (navigator.msSaveBlob) {\n    // IE 10+\n    navigator.msSaveBlob(blob, path);\n  } else {\n    const link = document.createElement('a'); // Browsers that support HTML5 download attribute\n\n    if (link.download !== undefined) {\n      const url = URL.createObjectURL(blob);\n      link.setAttribute('href', url);\n      link.setAttribute('download', path);\n      link.style.visibility = 'hidden';\n      document.body.appendChild(link);\n      link.click();\n      document.body.removeChild(link);\n    }\n  }\n};\n/*\n * Default options for browser worker\n */\n\n\nexports.defaultOptions = { ...defaultOptions,\n  workerPath: typeof process !== 'undefined' && process.env.TESS_ENV === 'development' ? resolveURL(\"/dist/worker.dev.js?nocache=\".concat(Math.random().toString(36).slice(3))) : \"https://unpkg.com/tesseract.js@v\".concat(version, \"/dist/worker.min.js\"),\n\n  /*\n   * If browser doesn't support WebAssembly,\n   * load ASM version instead\n   */\n  corePath: \"https://unpkg.com/tesseract.js-core@v2.0.0-beta.10/tesseract-core.\".concat(typeof WebAssembly === 'object' ? 'wasm' : 'asm', \".js\")\n};\n/**\n * spawnWorker\n *\n * @name spawnWorker\n * @function create a new Worker in browser\n * @access public\n * @param {object} instance - TesseractWorker instance\n * @param {object} options\n * @param {string} options.workerPath - worker script path\n */\n\nexports.spawnWorker = (instance, {\n  workerPath\n}) => {\n  let worker;\n\n  if (Blob && URL) {\n    const blob = new Blob([\"importScripts(\\\"\".concat(workerPath, \"\\\");\")], {\n      type: 'application/javascript'\n    });\n    worker = new Worker(URL.createObjectURL(blob));\n  } else {\n    worker = new Worker(workerPath);\n  }\n\n  worker.onmessage = ({\n    data\n  }) => {\n    if (data.jobId.startsWith('Job')) {\n      instance.recv(data);\n    } else if (data.jobId.startsWith('Download')) {\n      const path = data.path,\n            d = data.data,\n            type = data.type;\n      const blob = new Blob([d], {\n        type\n      });\n      downloadFile(path, blob);\n    }\n  };\n\n  return worker;\n};\n/**\n * terminateWorker\n *\n * @name terminateWorker\n * @function terminate worker\n * @access public\n * @param {object} instance TesseractWorker instance\n */\n\n\nexports.terminateWorker = instance => {\n  instance.worker.terminate();\n};\n/**\n * sendPacket\n *\n * @name sendPacket\n * @function send packet to worker and create a job\n * @access public\n * @param {object} instance TesseractWorker instance\n * @param {object} iPacket data for worker\n */\n\n\nexports.sendPacket = (instance, iPacket) => {\n  const packet = { ...iPacket\n  };\n  loadImage(packet.payload.image).then(buf => new Uint8Array(buf)).then(img => {\n    packet.payload.image = Array.from(img);\n    instance.worker.postMessage(packet);\n  });\n};","map":null,"metadata":{},"sourceType":"script"}