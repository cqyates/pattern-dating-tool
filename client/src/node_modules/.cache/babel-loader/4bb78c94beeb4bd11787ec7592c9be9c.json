{"ast":null,"code":"const isURL = require('is-url');\n\nconst fileType = require('file-type');\n\nconst axios = require('axios');\n\nconst handleLang = modules => ({\n  TessModule,\n  dataPath,\n  cachePath,\n  cacheMethod,\n  langCode\n}) => data => {\n  if (TessModule) {\n    if (dataPath) {\n      try {\n        TessModule.FS.mkdir(dataPath);\n      } catch (err) {// TODO: Do some error handling here.\n      }\n    }\n\n    TessModule.FS.writeFile(\"\".concat(dataPath || '.', \"/\").concat(langCode, \".traineddata\"), data);\n  }\n\n  if (['write', 'refresh', undefined].includes(cacheMethod)) {\n    return modules.writeCache(\"\".concat(cachePath || '.', \"/\").concat(langCode, \".traineddata\"), data).then(() => data);\n  }\n\n  return data;\n};\n\nconst loadAndGunzipFile = modules => ({\n  langPath,\n  cachePath,\n  cacheMethod,\n  gzip = true,\n  ...options\n}) => lang => {\n  const langCode = typeof lang === 'string' ? lang : lang.code;\n\n  const handleTraineddata = data => {\n    const type = fileType(data);\n\n    if (type !== null && type.mime === 'application/gzip') {\n      return modules.gunzip(new Uint8Array(data));\n    }\n\n    return new Uint8Array(data);\n  };\n\n  const doHandleLang = handleLang(modules)({\n    cachePath,\n    cacheMethod,\n    langCode,\n    ...options\n  });\n  let readCache = modules.readCache;\n\n  if (['refresh', 'none'].includes(cacheMethod)) {\n    readCache = () => Promise.resolve();\n  }\n\n  return readCache(\"\".concat(cachePath || '.', \"/\").concat(langCode, \".traineddata\")).then(data => {\n    if (typeof data === 'undefined') {\n      return Promise.reject();\n    }\n\n    return doHandleLang(data);\n  })\n  /*\n   * If not found in the cache\n   */\n  .catch(() => {\n    if (typeof lang === 'string') {\n      const fetchTrainedData = iLangPath => axios.get(\"\".concat(iLangPath, \"/\").concat(langCode, \".traineddata\").concat(gzip ? '.gz' : ''), {\n        responseType: 'arraybuffer'\n      }).then(({\n        data\n      }) => new Uint8Array(data)).then(handleTraineddata).then(doHandleLang);\n      /** When langPath is an URL, just do the fetch */\n\n\n      if (isURL(langPath) || langPath.startsWith('chrome-extension://')\n      /* for chrome extensions */\n      ) {\n          return fetchTrainedData(langPath);\n        }\n      /** When langPath is not an URL in Node.js environment */\n\n\n      return modules.readCache(\"\".concat(langPath, \"/\").concat(langCode, \".traineddata\").concat(gzip ? '.gz' : '')).then(handleTraineddata).then(doHandleLang);\n    }\n\n    return Promise.resolve(lang.data).then(handleTraineddata).then(doHandleLang);\n  });\n};\n/**\n *\n * @name loadLang\n * @function load language(s) from local cache, download from remote if not in cache.\n * @param {object}   options\n * @param {array}    options.langs -\n *     langs to load.\n *     Each item in the array can be string (ex. 'eng') or object like:\n *      {\n *        code: 'eng',\n *        gzip: false,\n *        data: Uint8Array\n *      }\n * @param {object}   options.TessModule - TesseractModule\n * @param {string}   options.langPath - prefix path for downloading lang file\n * @param {string}   options.cachePath - path to find cache\n * @param {string}   options.dataPath - path to store data in mem\n * @param {boolean}  options.gzip -\n *     indicate whether to download gzip version from remote, default: true\n * @param {string} options.cacheMethod -\n *     method of cache invaliation, should one of following options:\n *       write: read cache and write back (default method)\n *       readOnly: read cache and not to write back\n *       refresh: not to read cache and write back\n *       none: not to read cache and not to write back\n *\n */\n\n\nmodule.exports = modules => ({\n  langs,\n  ...options\n}) => Promise.all((typeof langs === 'string' ? langs.split('+') : langs).map(loadAndGunzipFile(modules)(options)));","map":null,"metadata":{},"sourceType":"script"}